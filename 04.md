---
# config: https://sli.dev/custom/
# https://sli.dev/guide/theme-addon.html#use-theme
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
background: https://cdn.jsdelivr.net/gh/slidevjs/slidev-covers@main/static/gSnIwHBKw3c.webp
# some information about your slides (markdown enabled)
title: Binary Search Patterns
# apply unocss classes to the current slide
class: text-center
# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: fade-out
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# Binary Search Patterns

Navigation

|                                                     |                             |
| --------------------------------------------------- | --------------------------- |
| <kbd>right</kbd> / <kbd>space</kbd>                 | next animation or slide     |
| <kbd>left</kbd>  / <kbd>shift</kbd><kbd>space</kbd> | previous animation or slide |
| <kbd>up</kbd>                                       | previous slide              |
| <kbd>down</kbd>                                     | next slide                  |

<div class="abs-br m-6 text-xl">
  <a href="https://github.com/dzianis-dashkevich/discussion-club" target="_blank" class="slidev-icon-btn">
    <carbon:logo-github />
  </a>
</div>

---

# Table of contents

<Toc minDepth="1" maxDepth="1" />

---

# Sliding Window Refresher

### Fixed Sliding Window

A fixed Sliding window maintains a specific length as it slides across a data structure.

If a fixed window of length `k` traverses a data structure from start to finish, it's guaranteed to see every subcomponent of length `k` in the data structure.


### Dynamic Sliding window

A dynamic sliding window can be applied to problems that ask us to find the longest or shortest subcomponent that satisfies a given condition (for example: all numbers in the window must be greater than 10).

---

## Generic Template for a fixed sliding window

```js
let left = 0;
let right = 0;
let currentData = null;
let res = null;

while (right < n) {
  // collect data
  currentData = update(dataStructure[right]);
  
  // if the window has reached the expected fixed length, we slide the window (shrink + expand)
  if (right - left + 1 === k) {
    // process the collected data for a given fixed window
    res = process(currentData);
    
    // update collected data as we shrink the window
    currentData = update(dataStructure[left]);
    
    // shrink the window
    left++;
  }
  
  // expand the window
  right++;
}
```

---

## Generic Template for a dynamic sliding window

```js
let left = 0;
let right = 0;
let currentData = null;
let res = null;

while (right < n) {
  // collect data
  currentData = update(dataStructure[right]);
  
  while (conditionIsViolated) {
    // update collected data as we shrink the window
    currentData = update(dataStructure[left]);
    
    // shrink the window until it is valid again
    left++;
  }
  
  // once the window is valid again, we process the collected data
  res = process(currentData);
  
  // expand the window
  right++;
}
```

---

## Sliding Window Refresher Problems

- [Longest Nice Substring](https://leetcode.com/problems/longest-nice-substring/description/)
- [Distinct Numbers in Each Subarray](https://leetcode.com/problems/distinct-numbers-in-each-subarray/description)

---

# Binary Search Intro

Binary search algorithms provide an efficient way to locate a target value in a *sorted* data structure by repeatedly halving the search space until the target is found.
This repeated division of the search space means that the algorithm runs in O(log n) time.

---

# Most Basic Example: Finding a Number in a Sorted Array

This is the most basic use case.

```js {*}{maxHeight:'340px'}
function binarySearch(arr, target) {
  // 1. Define left and right pointer
  // In this case, they are first first and last index of the array
  let left = 0;
  let right = arr.length - 1;
  
  // 2. Specify looping condition
  // In this case, the loop will execute for every single element in the array
  while (left <= right) {
    // 3. Calculate midpoint
    // Note: using Math.floor() biases the search space to the left when the number of elements being searched is even.
    // It is not strictly necessary to round down instead of up, but it is the norm.
    let mid = Math.floor((left + right) / 2);

    // 4. See if we've located the target at midpoint
    if (arr[mid] === target) {
        return mid;
    // 5. If midpoint is still below the target, set left pointer to the middle + 1 to continue the search in the right half
    } else if (arr[mid] < target) {
        left = mid + 1;
    // 6. If midpoint is above the target, set right pointer to middle - 1 to continue the search in the left half
    } else {
        right = mid - 1;
    }
  }
  
  // 7. If we get here, we have searched every element in the array and the target was not found
  return -1;
}
```

---

# Visualization

```js
/*
  Target: 7

  Iteration 1
  <---------------------------------------->
  [ l                                    r ]
  [ 1,   2,   3,   *4*,   5,   6,   7,   8 ]

  Iteration 2
                      <------------------->
                     [ l                r ]
  [ 1,   2,   3,   4,   5,   *6*,   7,   8 ]

  Iteration 3
                                <--------->
                                [ l     r ]
  [ 1,   2,   3,   4,   5,   6,   *7*,   8 ]

  7 is the "middle", target found!
*/
```

---

# Binary Search Variants

There are numerous variations of binary search depending on what we need to find. The two most common variations are:

1. **Lower Bound**: Finds the **first index** where `arr[i] >= target`.
2. **Upper Bound**: Finds the **first index** where `arr[i] > target`.

---

# Lower Bound (First index where `arr[i] >= target`)

```js
function lowerBound(arr, target) {
  let left = 0;
  let right = arr.length; // Notice: this is the length, not the last index
  
  while (left < right) {
    let mid = Math.floor((left + right) / 2);
    
    if (arr[mid] >= target) {
        right = mid;
    } else {
        left = mid + 1;
    }
  }

    // First index where arr[i] >= target
    // At this point, left === right, so we can return either, but returning `left` is the norm
    return left;
}

```

**Other example use-case:** Finding the first occurrence of a target in an array with duplicates

---

# Upper Bound (First index where `arr[i] > target`)

```js
function upperBound(arr, target) {
  let left = 0;
  let right = arr.length;
  
  while (left < right) {
    let mid = Math.floor((left + right) / 2);
    
    // Notice: the only thing that has changed from the Lower Bound implementation is this condition
    if (arr[mid] > target) {
        right = mid;
    } else {
        left = mid + 1;
    }
  }

  return left;
}
```

---

# Lower Bound vs. Upper Bound: Visualized

The distinction between Upper Bound and Lower Bound can be somewhat unintuitive, because the underlying concepts are not quite as symetrical as the names would suggest. It helps to see them visualized:

```js
/*
  Given the array:
    [1, 2, 2, 2, 2, 3, 4, 5, 6, 7, 8]
  
  The lower and upper bounds for `2` are:

  lowerBound(array, 2) ->  [ 1, *2*,  2,  2,  2,  3,  4,  5,  6,  7,  8 ]
                                 ^
  upperBound(array, 2) ->  [ 1,  2,  2,  2,  2, *3*,  4,  5,  6,  7,  8 ]
                                                 ^
*/
```

---

# Practice Problems

- [Sqrt(x)](https://leetcode.com/problems/sqrtx/description/)
- [Find First and Last Position of Element](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)
- [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

---
# TODO

```js
/*
 Discuss more generic template and highlight important implementation details that will differ depending on the problem:
 - How to determine the search space (left, right)
 - What is the looping condition: left <= right vs left < right
 - What condition should be used to evaluate the midpoint?
 - What needs to be returned?
*/
```

---