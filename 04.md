---
# config: https://sli.dev/custom/
# https://sli.dev/guide/theme-addon.html#use-theme
theme: default
# random image from a curated Unsplash collection by Anthony
# like them? see https://unsplash.com/collections/94734566/slidev
background: https://cdn.jsdelivr.net/gh/slidevjs/slidev-covers@main/static/gSnIwHBKw3c.webp
# some information about your slides (markdown enabled)
title: Binary Search Patterns
# apply unocss classes to the current slide
class: text-center
# https://sli.dev/features/drawing
drawings:
  persist: false
# slide transition: https://sli.dev/guide/animations.html#slide-transitions
transition: fade-out
# enable MDC Syntax: https://sli.dev/features/mdc
mdc: true
---

# Binary Search Patterns

Navigation

|                                                     |                             |
| --------------------------------------------------- | --------------------------- |
| <kbd>right</kbd> / <kbd>space</kbd>                 | next animation or slide     |
| <kbd>left</kbd>  / <kbd>shift</kbd><kbd>space</kbd> | previous animation or slide |
| <kbd>up</kbd>                                       | previous slide              |
| <kbd>down</kbd>                                     | next slide                  |

<div class="abs-br m-6 text-xl">
  <a href="https://github.com/dzianis-dashkevich/discussion-club" target="_blank" class="slidev-icon-btn">
    <carbon:logo-github />
  </a>
</div>

---

# Table of contents

<Toc minDepth="1" maxDepth="1" />

---

# Sliding Window Refresher

### Fixed Sliding Window

A fixed Sliding window maintains a specific length as it slides across a data structure.

If a fixed window of length `k` traverses a data structure from start to finish, it's guaranteed to see every subcomponent of length `k` in the data structure.


### Dynamic Sliding window

A dynamic sliding window can be applied to problems that ask us to find the longest or shortest subcomponent that satisfies a given condition (for example: all numbers in the window must be greater than 10).

---

## Generic Template for a fixed sliding window

```js
let left = 0;
let right = 0;
let currentData = null;
let res = null;

while (right < n) {
  // collect data
  currentData = update(dataStructure[right]);
  
  // if the window has reached the expected fixed length, we slide the window (shrink + expand)
  if (right - left + 1 === k) {
    // process the collected data for a given fixed window
    res = process(currentData);
    
    // update collected data as we shrink the window
    currentData = update(dataStructure[left]);
    
    // shrink the window
    left++;
  }
  
  // expand the window
  right++;
}
```

---

## Generic Template for a dynamic sliding window

```js
let left = 0;
let right = 0;
let currentData = null;
let res = null;

while (right < n) {
  // collect data
  currentData = update(dataStructure[right]);
  
  while (conditionIsViolated) {
    // update collected data as we shrink the window
    currentData = update(dataStructure[left]);
    
    // shrink the window until it is valid again
    left++;
  }
  
  // once the window is valid again, we process the collected data
  res = process(currentData);
  
  // expand the window
  right++;
}
```

---

## Sliding Window Refresher Problems

- [Longest Nice Substring](https://leetcode.com/problems/longest-nice-substring/description/)
- [Distinct Numbers in Each Subarray](https://leetcode.com/problems/distinct-numbers-in-each-subarray/description)

---

# Binary Search Intro

Binary search algorithms provide an efficient way to locate a target value in a *sorted* data structure by repeatedly halving the search space until the target is found.
This repeated division of the search space means that the algorithm runs in O(log n) time.

---

# Most Basic Example: Finding a Number in a Sorted Array

This is the most basic use case.

```js {*}{maxHeight:'340px'}
function binarySearch(nums: number[], target: number): number {
  // 1. Define left and right pointer
  // In this case, they are first first and last index of the array
  let left = 0;
  let right = arr.length - 1;
  
  // 2. Specify looping condition
  // In this case, the loop will execute for every single element in the array
  while (left <= right) {
    // 3. Calculate midpoint
    // Note: using Math.floor() biases the search space to the left when the number of elements being searched is even.
    // Depending on the problem, you may want to bias to the right by rounding up
    let mid = Math.floor((left + right) / 2);

    // 4. See if we've located the target at midpoint
    if (nums[mid] === target) {
        return mid;
    // 5. If midpoint is still below the target, set left pointer to the middle + 1 to continue the search in the right half
    } else if (nums[mid] < target) {
        left = mid + 1;
    // 6. If midpoint is above the target, set right pointer to middle - 1 to continue the search in the left half
    } else {
        right = mid - 1;
    }
  }
  
  // 7. If we get here, we have searched every element in the array and the target was not found
  return -1;
}
```

---

# Visualization

```js
/*
  Target: 7

  Iteration 1
  <---------------------------------------->
  [ l                                    r ]
  [ 1,   2,   3,   *4*,   5,   6,   7,   8 ]

  Iteration 2
                      <------------------->
                     [ l                r ]
  [ 1,   2,   3,   4,   5,   *6*,   7,   8 ]

  Iteration 3
                                <--------->
                                [ l     r ]
  [ 1,   2,   3,   4,   5,   6,   *7*,   8 ]

  7 is the "middle", target found!
*/
```

---

# Binary Search Variants

There are a number of variations of binary search depending on what we need to find. The two most common variations are:

- **Lower Bound:**
  - Finds the first position in an array where a target value appears, or the first position where a value could be inserted without breaking the order.
  - More generally, it identifies *the smallest index at which a given condition is satisfied*

- **Upper Bound:**
  - Finds the last position where a target value appears, or the last position a value could be inserted without breaking order. (Notice that these do not necessarily refer to the same index)
  - More broadly, it can also refer to *the first index where a condition is no longer met*, marking the end of a contiguous segment.

---

# Basic Lower Bound Example

In this example, the function looks for the *first* occurence of a repeating target number in a sorted array of numbers.

```js
function lowerBound(nums: number[], target: number): number {
  let left = 0;
  let right = nums.length - 1;

  while (left < right) {
    const mid = left + Math.floor((right - left) / 2);

    if (nums[mid] > target) {
        right = mid - 1;
    } else if (nums[mid] < target) {
        left = mid + 1;
    } else {
        right = mid;
    }
  }

  return nums[left] === target ? left : -1;
}
```

---

# Basic Upper Bound Example

In this example, the function looks for the *last* occurence of a repeating target number in a sorted array of numbers.

```js
function upperBound(nums: number[], target: number): number {
  let left = 0;
  let right = nums.length - 1;

  while (left < right) {
    const mid = left + Math.ceil((right - left) / 2);

    if (nums[mid] > target) {
        right = mid - 1;
    } else if (nums[mid] < target) {
        left = mid + 1;
    } else {
        left = mid;
    }
  }

  return nums[right] === target ? right : -1;
}
```

---

# Lower Bound vs. Upper Bound: Visualized

---

# First and Last Occurences

```js
/*
  Given the array:
    [1, 2, 2, 2, 2, 3, 4, 5, 6, 7, 8]
  
  When searching for the first and last occurences of target `2`:

  - lowerBound(array, 2) identifies the first index where a value equals target:
      [ 1, *2*,  2,  2,  2,  3,  4,  5,  6,  7,  8 ]
            ^
  
  - upperBound(array, 2) identifies the last index where a value equals a target:
      [ 1,  2,  2,  2,  *2*, 3,  4,  5,  6,  7,  8 ]
                         ^
*/

```

---

# Insertion Points

```js
/*
  Given the array:
    [1, 2, 2, 2, 2, 3, 4, 5, 6, 7, 8]
  
  When searching for an insertion point for an additional `2`:

  - lowerBound(array, 2) returns the first valid position where `2` can be inserted, which is at the first occurrence
      [ 1, *2*, 2, 2, 2, 3, 4, 5, 6, 7, 8 ]
            ^
  - upperBound(array, 2) returns the last valid position where `2` can be inserted without disrupting the order, which is at the first element greater than `2`:
      [ 1, 2, 2, 2, 2, *3*, 4, 5, 6, 7, 8 ]
                        ^
*/
```

---

# Monotonicity

Binary search doesn't strictly require a fully "sorted" array. What is essential is **monotonicity**â€” the property that once a condition holds at some point, it continues to hold in a specific direction.

Here again are two of our previous defintiions of Lower and Upper Bound:
- **Lower Bound** identifies *the smallest index at which a given condition is satisfied*
- **Upper Bound** identifies *the first index where a condition is no longer met*

---

```js {*}{maxHeight:'340px'}
/*
  Given the array:
    [1, 2, 4, 3, 0, 5, 7, 9, 8, 6]

  Notice that it is not sorted. However, also notice that every element before index 5 is `< 5`,
  and every element after index 5 is `> 5`. So, this array has some monotonicity that means
  we can use binary search on it
  
  Using Lower Bound binary search with this condition:
  - lowerBound(array, value >= 5) returns the first index where the condition becomes true:
      [ 1, 2, 4, 3, 0, *5*, 7, 9, 8 ]
                        ^

  We can represent this process in a more generic way using True (T) and False (F).
  Evaluating the condition (value >= 5) for each element produces:
    [ F, F, F, F, F, T, T, T, T ]
  
  Then:
  - lowerBound finds the first T:
      [ F, F, F, F, F, *T*, T, T, T ]
                        ^
  
  Now suppose we have the following array, represented abstractly:
    [ T, T, T, T, T, F, F, F, F ]

  - upperBound finds the first element where the condition is no longer true, the first F:
      [ T, T, T, T, T, *F*, F, F, F ]
                        ^
*/

```
---

# Practice Problems

- [Sqrt(x)](https://leetcode.com/problems/sqrtx/description/)
- [Find First and Last Position of Element](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)
- [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)

---
